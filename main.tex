\documentclass{beamer}

\usepackage{fancyhdr}
\usepackage[quiet]{fontspec}
\usepackage{tikz}
\usepackage{almslides}
\usepackage{moresize}
\usepackage{hyperref}

\usetikzlibrary{chains,decorations.pathmorphing,positioning,fit}
\usetikzlibrary{decorations.shapes,calc,backgrounds}
\usetikzlibrary{decorations.text,matrix}
\usetikzlibrary{arrows,shapes.geometric,shapes.symbols,scopes}
\usetikzlibrary{mindmap}

\setmonofont{Monaco}

\title{A Glance at MongoDB}
\author{Sheng Yuan}

\begin{document}
    
\begin{frame}
	\centering\includegraphics[width=0.7\textwidth]{MongoDB-Logo.png}
    \titlepage
\end{frame}

\begin{frame}{Contents}
    \tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}{Introduction}
	\begin{block}{Document Database}
		A record in MongoDB is a document, which is a data structure composed of field and value pairs. MongoDB documents are similar to JSON objects. The values of fields may include other documents, arrays, and arrays of documents.
	\end{block}
	\begin{block}{Key Features}
		\begin{itemize}
			\item High Performance
			\item Rich Query Language
			\item High Availability
			\item Horizontal Scalability
			\item Support for Multiple Storage Engines
		\end{itemize}
		
	\end{block}
    
\end{frame}

\section{Data Model}
\begin{frame}{Concepts}

\begin{minipage}[t]{0.5\textwidth}
	\scriptsize
	\begin{Alms*}
		\\
		\\
		\\
		> Documents \\
		> Collections \\
		> Database \\
		\\
		\\
		\\
		|\K{Mongodb}~~\ | \K{MySql}~~\ | \\
		|\A {Document}~\ | \A{Row}~~~~\ | \\
		|\A{Field}~~~~\ | \A{Column}~\ | \\
		|\A{Collection}| \A{Table}~~\ | \\
		|\A{Database}~\ | \A{Database}|\\
		|\A{Index}~~~~\ | \A{Index}~~\ |\\
	\end{Alms*}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
	\scriptsize
	\begin{Alms*}
		> \K{show} \V{dbs} \\
		admin \qquad 0.000GB\\
		local \qquad 0.000GB\\
		firebase \,0.001GB\\
		> \K{use} \V{firebase} \\
		switched to db firebase \\
		> \K{show} \V{collections} \\
		users \\
		models \\
		projects \\
		tasks \\
		> \V{db}.\V{users}.\V{find}().\V{pretty}() \\
		\{ \NI
		"\_id":ObjectId, \\
		"email":"liueh@tcl.com", \\
		"role":"admin"
		\ND \} \\
		\{ \NI
		"\_id":ObjectId, \\
		"email":"yuansheng@tcl.com", \\
		"role":"user"
		\ND \}
	\end{Alms*}
\end{minipage}

\end{frame}

\begin{frame}{Concepts}
	
\end{frame}

\begin{frame}{Data Types}
    \begin{itemize}
        \item Null
        \item Boolean
        \item Integer
        \item Double
        \item String
        \item Date
        \item Array
        \item Embedded Document
        \item ObjectId
        \item BinData
    \end{itemize}
\end{frame}

\section{Working with Data}
\begin{frame}{Mongo Shell}
    The mongo shell is an interactive JavaScript interface to MongoDB. 
    \begin{minipage}[t]{0.5\textwidth}
    	\scriptsize
    	\begin{Alms*}
    		\$ mongo \\
    		MongoDB shell version v3.4.3 \\
    		> \K{show} \V{dbs} \\
    		admin \qquad 0.000GB\\
    		local \qquad 0.000GB\\
    		firebase \,0.001GB\\
    		> \K{use} \V{firebase} \\
    		switched to db firebase \\
    		> \K{show} \V{collections} \\
    		users \\
    		models \\
    		projects \\
    		tasks \\
    		> \V{db}.\V{users}.\V{find}(\{
    		 \NI
    		"email":"liueh@tcl.com"
    		\ND \}).\V{pretty}() \\
    		\{ \NI
    		"\_id":ObjectId, \\
    		"email":"liueh@tcl.com", \\
    		"role":"admin"
    		\ND \}
    	\end{Alms*}
    \end{minipage}
\end{frame}

\begin{frame}{CRUD Operations}
    \begin{minipage}[t]{0.7\textwidth}
        \scriptsize
        \begin{Alms*}
            > db.users.insert(\{"name":"yuansheng"\}) \\
            > db.users.insert(\NI\{"name":"yuansheng", "age":23\}\ND) \\
            > db.users.insert(\NI\{"name":"liueh", "job":"programmer"\}\ND) \\
            > db.users.find().pretty() \\
            \{ \NI
                "\_id" : ObjectId("58eda18e1d41c860ce59966e"), \\
                "name" : "yuansheng" \\
            \ND \} \\
            \{ \NI
                "\_id" : ObjectId("58eda18e1d41c860ce59966e"), \\
                "name" : "yuansheng" \\
                "age": 23 \\
            \ND \} \\
            > db.users.find(\{"name":"yuansheng"\}).pretty() \\
            > db.users.find(\{"name":"yuansheng"\}).count() \\
            > db.users.find(\{"age":23\}).pretty() \\
        \end{Alms*}
    \end{minipage}
\end{frame}

\begin{frame}{CRUD Operations}
	\begin{minipage}[t]{0.45\textwidth}
		\scriptsize
		\begin{Alms*}
			> db.users.find(\{\NI
			"name":"yuansheng", "age":23
			\ND\}).pretty() \\
			> db.users.find(\{ \NI\$or: [\{age:\{\$gt:18\}\}, \{age:\{\$lt:30\}\}] \ND\})\\
			> db.users.update(\NI
			\{"name":"yuansheng"\},\\
			\{"\$set":\{"name":"yuansheng", "job":"teacher"\}\}
			\ND )
			> db.users.remove(\NI
			\{"name":"yuansheng"\}
			\ND )
		\end{Alms*}
	\end{minipage}
\end{frame}

\begin{frame}{CRUD Operations}
	\begin{minipage}[t]{0.48\textwidth}
		\scriptsize
		\begin{Alms*}
			db.createCollection() \\
			db.collection.drop() \\
			\\
			db.collection.insert() \\
			db.collection.insertOne() \\
			db.collection.insertMany() \\
			\\
			db.collection.find() \\
			db.collection.findOne() \\
			db.collection.findMany() \\
			\\
			db.update()  \\
			db.updateOne() \\
			db.updateMany() \\
			db.collection.replaceOne() \\
			\\
			db.collection.deleteOne() \\
			db.collection.deleteMany() \\
			db.collection.remove()
			
		\end{Alms*}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.48\textwidth}
		\scriptsize
		\begin{Alms*}
			db.collection.findAndModify() \\
			db.collection.findOneAndUpdate() \\
			db.collection.findOneAndDelete() \\
			db.collection.findOneAndReplace() \\
			
		\end{Alms*}
	\end{minipage}
\end{frame}

\section{Advanced Queries}
\begin{frame}
    
\end{frame}

\section{Python and MongoDB}
\begin{frame}{Python and MongoDB}
\scriptsize
\begin{Alms*}
	\T{int} \V{udp\_sendmsg}(\T{struct sock *}\V{sk},
	\T{struct msghdr *}\V{msg}, \textrm{\ldots}) \\
	\{ \NI
	\vdots \\
	\tikzanchor{lock 1}%
	\only<8->{\highlight<8-9>{\V{lock\_sock}(\V{sk});} \\}%
	\K{if} \highlight<6-8>{(\V{unlikely}(\V{sk}$→$\V{pending}))} \{ \NI
	\highlight<5>{
		\CCOM{Socket is already corked while preparing it} \\
		\CCOM{\ldots\,which is an evident application bug. --ANK}
	} \\
	\only<9->{\highlight<9>{\V{release\_sock}(\V{sk});} \\}%
	\V{LIMIT\_NETDEBUG}(\V{KERN\_DEBUG} \S{udp cork app bug 2}); \\
	\highlight<6>{\K{return} -\D{EINVAL};}
	\ND\} \\[4pt]
	\tikzanchor{lock 2}%
	\only<-7>{\highlight<2,7>{\V{lock\_sock}(\V{sk});} \\}%
	\highlight<3>{%
		\V{ret} = \V{ip\_append\_data}(\V{sk}, \V{msg}$→$\V{msg\_iov},
		\V{ulen}, \textrm{\ldots});} \\
	\vdots \\
	\highlight<4>{\V{release\_sock}(\V{sk});} \\
	\K{return} \V{ret};
	\ND\}
\end{Alms*}
\end{frame}

\section{GridFS}
\begin{frame}{GridFS}
	GridFS is a specification for storing and retrieving files that exceed the BSON-document size limit of 16 MB.
	\vspace{0.05\textheight}
	
	\begin{minipage}[t]{0.45\textwidth}
		%\includegraphics[width=\linewidth]{golang}
		Instead of storing a file in a single document, GridFS divides the file into parts, or chunks, and stores each chunk as a separate document. By default, GridFS uses a chunk size of 255 kB; that is, GridFS divides a file into chunks of 255 kB with the exception of the last chunk.
	\end{minipage}%
	\hfill
	\begin{minipage}[t]{0.45\textwidth}
		\scriptsize
		\begin{Alms*}
		 \$ \K{mongofiles} -d=test \K{list}\\
         \$ \K{mongofiles} \K{put} <filename>\\
         \$ \K{mongofiles} \K{get} <filename>\\
         \$ \K{mongofiles} \K{delete} <filename>\\
         \$ \K{mongofiles} \K{search} <filename>\\
         \$ \K{mongofiles} \K{get\_id} <\_id>\\
         \$ \K{mongofiles} \K{delete\_id} <\_id>\\
		\end{Alms*}
	\end{minipage}
\end{frame}

\begin{frame}{GridFS}
	\begin{minipage}[t]{\textwidth}
		GridFS\cite{Chodorow2013MongoDB} uses two collections to store files. One collection stores the file chunks, and the other stores file metadata.
	\end{minipage}
    
    \begin{block}{fs.files}
        \scriptsize
        \begin{Alms*}
            \{ \NI
                "\_id" : ObjectId("58eda18e1d41c860ce59966e"), \\
                "chunkSize" : 261120, \\
                "uploadDate" : ISODate("2017-04-11T11:15:52.551Z"), \\
                "length" : 237406045, \\
                "md5" : "2166f11cee1bd4b2c31fc429524fdae0", \\
                "filename" : "The.Big.Bang.Theory.S01E01.mkv" \\
            \ND \}
        \end{Alms*}
    \end{block}
    
    \begin{block}{fs.chunks}
        \scriptsize
        \begin{Alms*}
            \{ \NI
            "\_id" : ObjectId("58ecbae81d41c81b3962e857"), \\
            "files\_id" : ObjectId("58ecbae81d41c81b3962e856"), \\
            "n" : 0, \\
            "data" : BinData("...")
            \ND \}
         \end{Alms*}
    \end{block}
    
\end{frame}

\begin{frame}{When to Use GridFS}
    \begin{itemize}
        \item If your filesystem limits the number of files in a directory, you can use GridFS to store as many files as needed.
        \item When you want to access information from portions of large files without having to load whole files into memory, you can use GridFS to recall sections of files.
        \item When you want to keep your files and metadata automatically synced and deployed across a number of systems and facilities, you can use GridFS.
        \item \textcolor{red}{Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. }
        \item \textcolor{red}{If your files are all smaller the 16 MB BSON Document Size limit, consider storing the file manually within a single document instead of using GridFS.}
    \end{itemize}
\end{frame}

\section{Replication}
\subsection{Why Replication}
\begin{frame}{Why Replication}
    A replica set in MongoDB is a group of mongod processes that maintain the same dataset. With multiple copies of data on different database servers, replication provides a level of fault tolerance against the loss of a single database server.
\end{frame}

\subsection{How Replication Works}
\begin{frame}{How Replication Works}
    
\end{frame}

\subsection{Replica Set Administration}
\begin{frame}{Replica Set Administration}
    
\end{frame}


\section{Database Administration}
\begin{frame}{Database Administration}
\subsection{Backup and Restore}
The MongoDB backup utility is called mongodump; this utility is supplied as part of the standard distribution.
\end{frame}

\subsection{Protect your Server with  Authentication}
\begin{frame}{Database Administration}
    
\end{frame}

\section{Optimization}
\begin{frame}{Optimization}
	
\end{frame}

\section{MonogDB vs MySQL}
\begin{frame}{MonogDB vs MySQL}
    
\end{frame}

\begin{frame}{References}
	\small
    \bibliography{ref}
    \bibliographystyle{plain}
\end{frame}

\end{document}
